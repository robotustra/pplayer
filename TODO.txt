What must to be done.


Интерпретатор должен перевести запись в некий универсальный язык, над которым он может производить вычисления.

(1) Итак, первая стадия это выделение слов и определение их смысла как слов.
Это первый слой сканирования.

Если не известны вводимые слова, то по написанию они должны пройти через ряд правил, прежде чем интерпретатор скажет, что он про них думает.

Например, если есть правила определения числа, переменной, или еще чего, то они должны быть проверены.

После проверки, если все еще есть неизвестные слова и догадаться о их смысле невозможно, то проверяются опечатки в словах по расстоянию Левенштейна до 3.

Если и после этого не обнаружено сходство слов, то интерпретатор выдает ошибку.

(2) Если установлены все слова, между ними устанавливается зависимость, и строится дерево параметров, переменных и операций над ними.

Уже на этом уровне должно быть понятно как интерпретировать получившуюся структуру. Если же полученная структуры невычислима в силу неполноты данных, то уже на этом уровне определяется чего не достает и вопрос отсылается на первый уровень, где он передается человеку.

То есть по сути дела это перевернутая работа неокортекса.

То есть у нас должен быть плеер и парсер для двух слоев.
А то и трех.

Так и будем называть их

PlayerL3, ParserL3
PlayerL2, ParserL2
PlayerL1, ParserL1.

Player3 интерпретирует ввод как написано в пункте (1). И переводит его в язык второго уровня. Далее интерпретатор переводит его в язык первого уровня. Далее производятся вычисления и парсер результата переводит его обратно в язык более высокого уровня если это нужно. И передает наверх.

То есть мне нужно сделать:
(1) Понять какая должна быть форма языка второго уровня, придумать N примеров перевода из языка L3 в L2 и наоборот, и сформулировать алгоритмы для парсера и плэйера. Повторить то же самое для уровней L2 и L1.

допустим, мы можем делать подстановки типа:

("сколько будет" expr ) -> evaluate(expr)

(expr1 "+" expr2) -> try_add(expr1, expr2)

("пусть" expr) -> expr
("допустим" expr) -> expr

(expr1 "=" expr2) -> { if ( isVariable(expr1) && isValue(expr2) ) {expr = evaluate(expr2); } 
						else {/* можем определить другой смысл для знака = */} }

В принципе, для описания арифметических вычислений язык второго уровня может оказаться вполне каким-либо языком программирования. И хорошо, если этот язык будет интерпретируемым.

Короче нужно придумать правила для интепретации вводимых слов и составить список этих самых вводимых слов.

Составляем список слов:

========================================================================================================
пусть, сумма, разность, произведение, переменная, значение, +, -, плюс, минус, *, умножить, /, разделить
сколько будет, вычислить, [a..z,A..Z,А..Я,а..Я], величина, массив, матрица, список, размерность,
функция, ответ.
========================================================================================================

Если будут определяться какие-то другие слова, то следует будет ввести парсер и плеер более высокого 
уровня.

По идее все слова должны будут определяться через слой самого низкого уровня по любому. Эти определения нужно будет переводить в слои более низкого уровня.



Слово определено, если заданы все его степени свободы. То есть хочешь не хочешь, а писать слой мне 
придется. Проект pplayer.


------------------------------

1) Разделить входной поток на слова и найти их в локальной базе данных. 
Подгрузить определения слов. 
Локальная база данных это просто один файл, содержащий символы и их определения.

	Формат базы очень простой:
	
	хедер символа, 
	символ, 
	футер стмвола, 
	хедер описания 1, 
	описание, 
	футер описания 1, 
	[{хедер описания 2, описание, футер описания 2,] 



1.1) Разбить слова на группы, в соответствии с коротыми они должны быть интерпретированы, и на последовательности групп интерпретации.

Различаемые последовательности типов объектов и способ их интерпретации, должен быть в базе так же.

	
	хедер сочетания объектов,  
	имя объекта1, 
	имя объекта2, 
	...., 
	футер сочетания объектов,
	херер перевода, 
	символ1, 
	символ2, 
	символ3, 
	.... , 
	футер перевода.



Следует различать объекты и символы. Символы не имеют описания и просто используются для описания объектов.
Объект должен иметь в себе хотя бы одно описание, состоящее из символов и других объектов.
Символ - это объект без описания.

Так же должны быть 

	динамические объекты, 

которые распознаются автоматически и не хранятся в базе данных, и передаются ниже или выше без изменения. Их имя и есть описание. Динамических объекты опознаются, но не интерпретируются, а передаются "as is".


например, имеем предложение:

32.34 + 4342

должен распознаться как 
	
	динамический объект число 1,
	прибавить,
	динамический объект число 2.

и должен быть проинтерпретирован как
	
	plus( 32.34, 4342)





2) Проинтерпретировать входной поток в соответствии с определениями.

3) Сделать механизм добавления новых слов. В парсер и в плэйер.

=====================================================================
31.12.2013
----------

Синтаксис и грамматика предложений для парсера-плеера.

Ввод информации должен отсуществляться на языке близком к обычному, с обычными знаками препинания, математические знаки и символы, цифры и скобки должны интерпретироваться обычным образом.

Разбор предложения должен начинаться с блоков. Первая буква должна быть заглавной, даже если это не так, то она делается заглавной. Каждый ввод рассматривается как одно предложение. Предложения могут быть повелительные, повествовательные, вопросительные.

1) Повествовательные предложения - это ввод параметров, задание начальных условий.

В повествовательных преложениях основными словами будет:
------------------------------------
	пусть, допустим, что, равно, равняется, величина,

	примеры:
	--------
	Пусть Х равно 5.
	Допустим, что Z = 10, а t=0.01.
	Предположим, что Н = 20 и S = 15.
	Считаем A=5, P=10, D=18.


2) Повелительные предложения - это выполнение определенных функций.
	
	Напечатай "Hello World".
	Найти расстояние между точками A и B.
	Высилить корень квадратный из C.
	Найти площадь треугольника ABC.


3) Вопросительные - выем значений из памяти.

	Чему равен X?
	Чему равно В?
	Какова длинна стороны AB?

4) Cмешанные предложения. Вопросительные + повествовательные.

	Сколько будет G/D если G=10, а D = 4?

Так же должен быть способ задания инструкции и выполение инструкции по шагам. Например, описание вычисления расстояния:

	Расстояние между точками A с координатой (x,y) и В с координатами (x1,y1) вычисляется 
	по формуле D = ( (x1-x)^2 + (y1-y)^2 ) ^ (1/2).

И после такого ввода должно быть понятен вопрос типа: 

	Чему равно расстояние между точками (2,4) и (4,5)?

или 

	Пусть T =  расстоянию между точками (2,6) и (4,3).

Это смесь повествовательного и повелительного предложения. То есть интерпретатор должен уметь переформулировать предложение и разбить его на стандартизированные простые предложения.

	"Пусть T =  расстоянию между точками (2,6) и (4,3)."

Должно быть переформулировано так:

	"Пусть есть точка Имя1(2,6) и точка Имя2(4,3). 
	Вычислить расстояние между точками Имя1 и Имя2, сохранить значение в T."

------------------------------------------------------------------------------------
То есть первый этап разбора предложения - перевод его в стандартизированную форму. Или нормализация.
Назовем это единичным преобразованием смысла.

Начнем с задания параметров. Это будут повествовательные предложения. Что нужно сделать первым делом?
Скорректировать грамматику или правописание.

	пусть а = б и с = д.
	Пусть а равно б. Пусть с равно д.

То есть по сути дела избавление от "И", "в то время как", "тогда как", "в то же время", ",", "а"
и другие слова, связывающие предложения.


---------------------------------

Каждое слово связано с другим в предложении или с группой слов. То есть связь слов в предложении можно поедставить в виде матрицы с дробными индексами. 

Для простых предложений можно составить матрицу связи между словами. 

Выделение признаков слов можно делать по словарю, если научится декодировать признаки. По этим признакам устанавливается связь в предложениях.

для словосочетаний может быть паттерн, который состоит из сочетания признаков двух отдельно взятых слов.

слов-о			слов-а
слов-а 			слов-
слов-у 			слов-ам
слов-о 			слов-а
слов-ом 		слов-ами
слов-е 			слов-ах		

У существительных может быть 2 признака, это чило и падеж.
Как насчет обобщенных признаков, под которые могут подпадать не только русские или английские слова.

Признак слова может модицицировать слово до неузнаваемости. Допустим, у нас есть признак действующий на слово, тогда, любое слово можно переписать в виде:

число(падеж(слово))

При этом, число() и падеж() комутативны. Более того, если последовательности слов имеют одинаковые признаки, то они могут быть сгруппированы.

Получается, что это один из способов определения зависимых слов.

	http://sibac.info/index.php/2009-07-01-10-21-16/6119-2013-01-29-08-54-47

То есть одним из критериев обобщения будет вынесение за скобки общих признаков.

Некторые слова могут не изменяться под действием признаков. Поэтому такие слова может быть трудно ассоциировать со смысловыми словами. 

Возможно предлоги можно относить к признакам. например, 

на столе
на столах

Предложный падеж 

хорош-ий счет
хорош-его счет-а
хорош-ему счет-у
хорош-ий счет
хорош-им счет-ом

о хорош-ем счет-е
на хорош-ем счет-у

то есть в зависимости от предлога может видоизменяться слово.

1) Первый этап это выделение признаков по отдельным словам. запись в матрицу флагов признаков.

2) Установление групп слов с общими признаками, и перестановка слов в предложении.

	Иногда( я хожу в магазин ) = Иногда( я(ходить)(в(магазин)) ) 

лицо(ходить)

2.01.2014
---------

1) Создать список слов, которые будут использоваться в интерпретаторе, выделить изменяемую часть, 
просклонять, проспрягать.
	
	Я буду использовать ограниченный набор слов для описания задач. Потом набор слов можно будет расширить.
	Слова будут храниться в файле dict.txt

2) Придумать как автоматически выделять признаки слов.
3) Научиться группировать слова по признакам.

(Изменяемые слова заменить неизменяемыми частями + изменяемой структурой.)

У глагола есть 7 возможных модификаторов. То есть это получается достаточно большая матрица. 

вид (совершенный (что сделать?), несовершенный (что делать?)), 
лицо (1 лицо(я, мы), 2 лицо (ты, вы), 3 лицо(он, она, оно, они)), 
род (кроме настоящего и будущего), 
число (мн., ед.), 
наклонение(изъявительное, условное, сослагательное, желательное, повелительное),
время (прошедшее, настощее, будущее), 
залог (действительный, страдательный).

Вероятно можно уменьшить число степеней свободы глаголов объеденив некоторые измерения, таке как
лицо и число.

Так же можно разделить залог и вид (учетверить количество глаголов), чтобы уменьшить число степеней
свободы до 4. 

Тогда остается только 4 признака:

лицо + число (1 лицо(я, мы), 2 лицо (ты, вы), 3 лицо(он, она, оно, они)), 
род(кроме настоящего и будущего), 
наклонение(изъявительное, условное, сослагательное, желательное, повелительное),
время (прошедшее, настощее, будущее), 


